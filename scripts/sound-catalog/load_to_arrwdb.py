#!/usr/bin/env python3
"""
Load sound catalog with embeddings into arrwDB.

This script:
1. Creates a 'strudel-sounds' library in arrwDB
2. Uploads all sounds with pre-computed embeddings
3. Uses the /documents/batch-with-embeddings endpoint (no Cohere needed!)

Prerequisites:
1. arrwDB running at http://localhost:8000
2. sound_catalog_with_embeddings.json generated by generate_embeddings.py
"""

import json
import os
import sys
from pathlib import Path
from typing import Optional

import httpx


# arrwDB configuration
# Default port 8001 to avoid conflict with other services on 8000
ARRWDB_BASE_URL = os.environ.get("ARRWDB_URL", "http://localhost:8001")
LIBRARY_NAME = "strudel-sounds"
LIBRARY_DESCRIPTION = "Strudel/TidalCycles sound catalog for semantic search"


def check_arrwdb_health(client: httpx.Client) -> bool:
    """Check if arrwDB is running."""
    try:
        response = client.get(f"{ARRWDB_BASE_URL}/health")
        return response.status_code == 200
    except Exception as e:
        print(f"Error connecting to arrwDB: {e}")
        return False


def get_or_create_library(client: httpx.Client, force: bool = False) -> Optional[str]:
    """Get existing library or create new one."""

    # List existing libraries
    response = client.get(f"{ARRWDB_BASE_URL}/v1/libraries")
    if response.status_code != 200:
        print(f"Error listing libraries: {response.text}")
        return None

    libraries = response.json()

    # Check if our library exists
    for lib in libraries:
        if lib["name"] == LIBRARY_NAME:
            print(f"Found existing library: {lib['id']}")

            if force:
                # Force mode: delete and recreate
                print("Force mode: deleting existing library...")
                delete_response = client.delete(f"{ARRWDB_BASE_URL}/v1/libraries/{lib['id']}")
                if delete_response.status_code == 204:
                    print("Deleted existing library")
                else:
                    print(f"Error deleting library: {delete_response.text}")
                    return None
            else:
                # Interactive mode or reuse existing
                try:
                    user_input = input("Library exists. Delete and recreate? (y/n): ").strip().lower()
                    if user_input == "y":
                        delete_response = client.delete(f"{ARRWDB_BASE_URL}/v1/libraries/{lib['id']}")
                        if delete_response.status_code == 204:
                            print("Deleted existing library")
                        else:
                            print(f"Error deleting library: {delete_response.text}")
                            return None
                    else:
                        return lib["id"]
                except EOFError:
                    # Non-interactive, reuse existing
                    print("Non-interactive mode: reusing existing library")
                    return lib["id"]

    # Create new library
    print(f"Creating library: {LIBRARY_NAME}")
    create_data = {
        "name": LIBRARY_NAME,
        "description": LIBRARY_DESCRIPTION,
        "index_type": "hnsw",  # Best for semantic search
    }

    response = client.post(
        f"{ARRWDB_BASE_URL}/v1/libraries",
        json=create_data,
    )

    if response.status_code == 201:
        library_id = response.json()["id"]
        print(f"Created library: {library_id}")
        return library_id
    else:
        print(f"Error creating library: {response.text}")
        return None


def upload_sounds_batch(
    client: httpx.Client,
    library_id: str,
    sounds: list[dict],
    batch_size: int = 50,
) -> tuple[int, int]:
    """Upload sounds in batches using pre-computed embeddings."""

    total_success = 0
    total_failed = 0

    # Process in batches
    for i in range(0, len(sounds), batch_size):
        batch = sounds[i : i + batch_size]
        batch_num = i // batch_size + 1
        total_batches = (len(sounds) + batch_size - 1) // batch_size

        print(f"Uploading batch {batch_num}/{total_batches} ({len(batch)} sounds)...")

        # Prepare documents for arrwDB
        documents = []
        for sound in batch:
            # Each sound becomes a document with one chunk
            doc = {
                "title": sound["name"],
                "chunks": [
                    {
                        "text": sound["search_text"],
                        "embedding": sound["embedding"],
                    }
                ],
                "author": sound["source"],
                "document_type": "sound",
                "tags": sound["tags"][:10],  # arrwDB limits tags
            }
            documents.append(doc)

        # Upload batch
        response = client.post(
            f"{ARRWDB_BASE_URL}/v1/libraries/{library_id}/documents/batch-with-embeddings",
            json={"documents": documents},
            timeout=60.0,  # Longer timeout for batch
        )

        if response.status_code == 201:
            result = response.json()
            total_success += result["successful"]
            total_failed += result["failed"]
            print(f"  Success: {result['successful']}, Failed: {result['failed']}")
        else:
            print(f"  Error: {response.text}")
            total_failed += len(batch)

    return total_success, total_failed


def test_search(client: httpx.Client, library_id: str):
    """Test semantic search on the library using local BGE-M3 embeddings."""

    # Import embedding generator (same as our backend uses)
    try:
        from generate_embeddings import generate_embedding
        print("\n" + "=" * 50)
        print("TESTING SEMANTIC SEARCH (local BGE-M3 embeddings)")
        print("=" * 50)
    except ImportError:
        print("\n[Skip] Cannot import generate_embeddings for testing")
        print("Tests require generate_embeddings.py in the same directory")
        return

    test_queries = [
        "warm electric piano for jazz",
        "heavy bass for dubstep",
        "orchestral strings cinematic",
        "japanese traditional instrument",
        "punchy kick drum electronic",
        "ambient pad atmospheric",
    ]

    for query in test_queries:
        print(f"\nQuery: '{query}'")

        try:
            # Generate embedding locally (same as our Node.js backend)
            embedding = generate_embedding(query)

            # Use /search/embedding endpoint (bypasses Cohere!)
            response = client.post(
                f"{ARRWDB_BASE_URL}/v1/libraries/{library_id}/search/embedding",
                json={"embedding": embedding, "k": 3},
            )

            if response.status_code == 200:
                results = response.json()
                for i, result in enumerate(results["results"], 1):
                    title = result["document_title"]
                    distance = result["distance"]
                    similarity = 1 - distance
                    print(f"  {i}. {title} (similarity: {similarity:.2%})")
            else:
                print(f"  Error: {response.text}")
        except Exception as e:
            print(f"  Error generating embedding: {e}")


def main(embeddings_path: Optional[str] = None, force: bool = False):
    """Load sound catalog into arrwDB."""

    # Default path
    script_dir = Path(__file__).parent
    if embeddings_path is None:
        embeddings_path = script_dir / "sound_catalog_with_embeddings.json"
    else:
        embeddings_path = Path(embeddings_path)

    # Check file exists
    if not embeddings_path.exists():
        print(f"Error: Embeddings file not found: {embeddings_path}")
        print("Run generate_embeddings.py first!")
        sys.exit(1)

    # Load sounds with embeddings
    print(f"Loading embeddings from: {embeddings_path}")
    with open(embeddings_path) as f:
        sounds = json.load(f)
    print(f"Loaded {len(sounds)} sounds with embeddings")

    # Verify embeddings exist
    if "embedding" not in sounds[0]:
        print("Error: Sounds don't have embeddings!")
        print("Run generate_embeddings.py first!")
        sys.exit(1)

    embedding_dim = len(sounds[0]["embedding"])
    print(f"Embedding dimension: {embedding_dim}")

    # Connect to arrwDB
    print(f"\nConnecting to arrwDB at {ARRWDB_BASE_URL}...")
    client = httpx.Client(timeout=30.0)

    if not check_arrwdb_health(client):
        print("Error: arrwDB is not running!")
        print(f"Start arrwDB with: cd /Users/bledden/Documents/arrwDB && python3 run_api.py")
        sys.exit(1)

    print("arrwDB is healthy!")

    # Get or create library
    library_id = get_or_create_library(client, force=force)
    if not library_id:
        print("Error: Could not get or create library")
        sys.exit(1)

    # Upload sounds
    print(f"\nUploading {len(sounds)} sounds to arrwDB...")
    success, failed = upload_sounds_batch(client, library_id, sounds)

    # Summary
    print("\n" + "=" * 50)
    print("UPLOAD COMPLETE")
    print("=" * 50)
    print(f"Successful: {success}")
    print(f"Failed: {failed}")
    print(f"Library ID: {library_id}")

    # Test search
    if success > 0:
        test_search(client, library_id)

    print("\n" + "=" * 50)
    print("SETUP COMPLETE!")
    print("=" * 50)
    print(f"\narrwDB is ready for semantic sound search.")
    print(f"Library: {LIBRARY_NAME} ({library_id})")
    print(f"\nAPI endpoint: POST {ARRWDB_BASE_URL}/v1/libraries/{library_id}/search")
    print('Example: {"query": "warm piano jazz", "k": 5}')


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Load sound catalog into arrwDB")
    parser.add_argument("--embeddings", type=str, help="Path to embeddings JSON")
    parser.add_argument("--force", "-f", action="store_true",
                        help="Delete existing library and recreate (no prompt)")

    args = parser.parse_args()
    main(embeddings_path=args.embeddings, force=args.force)
